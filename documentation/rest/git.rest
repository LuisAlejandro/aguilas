Working with git
================

Git is a free and open source, distributed version control system designed to handle everything from small to very large projects with speed and efficiency. If you want a list of common commands, see the `cheatsheet <cheatgit.rest>`_ or it's `graphical summary <http://zrusin.blogspot.com/2007/09/git-cheat-sheet.html>`_.

For those too impatient to read, here's what you need to work with someone else's Git project::

	git clone [URL]
	git add .
	git commit -a
	git push
	git pull

Before running any command the first time, it's recommended that you skim through its manual page. Many of the commands have very useful and interesting features (that we won't list here) and sometimes there are some extra notes you might want to know. You can also get help on any Git command by doing ``git [COMMAND] -h`` or ``git help [COMMAND]``.

Installing git
--------------

If you are using Debian, Ubuntu, Canaima or other Debian derivative, you can install git easily with the following command (was an administrator user)::

	aptitude install git-core

Configuring git
---------------

Git includes your real name and your e-mail address on every commit you make. You should add these before you start using Git::

	git config --global user.name "Your Complete Name"
	git config --global user.email you@yourdomain.example.com

``git config`` is the command to set configuration options. While you're configuring, here are some other things you might like to do::

	# colorized `git diff`, etc.
	git config --global color.ui auto

	# list all configuration options
	git config -l

Creating a New Repository
-------------------------

Let's step through how you create and update a new project:

If you are creating a new project, you should::

	mkdir myproject; cd myproject
	git init

If you are putting an existing project under git version control, you should::

	cd myproject
	git init
	git add .
	git commit -a

``git init`` initializes the repository, ``git add .`` adds all the files under the current directory and ``git commit -a`` creates the initial import of files.

If you are downloading someone else's git project, you should do this instead::

	git clone [URL]

Whichever the case, now your tree is officially tracked by git. One nice thing to note - no matter how many subdirectories your project has, there's only one .git directory that contains all the version control information. Do some random changes to your tree now - poke around in a few files or something.

Making Changes
--------------

When you've edited some files, next thing you have to do is add them to version control. First you check what you've done::

	git diff

That's it. This is one of the more powerful commands. To get a diff with a specific commit, do::

	git diff [COMMIT]

You can obtain the commit number by listing all commits with::

	git log

Also, there is a more concise representation of changes available::

	git status

This will show the concise changes summary as well as list any files that you haven't either ignored or told Git about. In addition, it will also show at the top which branch you are in.

The status command also shows the "untracked files" that Git doesn't know what to do with. You can either include them in the registry (in the case these are new files)::

	git add .

Or delete them (in the case these are unwanted files from a build process, for example). *WARNING* this will delete all untracked files forever::

	git clean -fd

You could also list all files you want to ignore forever. These files will never be added to version control. What you need to do is create a file named ``.gitignore``, containing a list of the files, line by line.

If you made changes to a file that you want to undo, you can get back the last version you committed::

	git checkout [PATH/TO/FILE]

So after you have messed around with the project files, it's about time for us to commit our changes::

	git commit -a

There are two considerations to observe:

First, you have to specify ``-a`` if you want to commit all your files, or ``git commit [PATH/TO/FILE]`` to commit file by file.

Second, Git commits are private by default - they aren't pushed to any central server unless you specify it. We'll talk about pushing changes later, but private commits have some important benefits. For example, when you realise you left some debugging iformation in your last commit, or made a typo in the commit message, you can do ``git commit --amend`` to fix it, or even do ``git reset HEAD^`` to toss the commit away completely without affecting your files.

A few words about the commit message: it is customary to have a short commit summary as the first line of the message, because many tools just show the first line of the message. You can specify the commit message using the -m parameter (extra -m arguments will create extra paragraphs in the commit message).

Browsing
--------

Now that we have committed some stuff, you might want to review your history::

	git log
	git blame [PATH/TO/FILE]

The ``log`` command is very powerful, it shows you the complete history of the project, commit by commit, and also extra information like authors and dates. For example, ``git log --oneline`` will show you the first few characters of each commit ID and the first line of each commit message. See the *git-log manual page* for more stuff git log can do.

The ``blame`` command is also very useful, as it identifies the author of every line of every file registered by git.

You can see the contents of a file, the listing of a directory or a commit with::

	git show [COMMIT]:[PATH/TO/FILE]
	git show [COMMIT]:[PATH/TO/DIRECTORY]
	git show -s [COMMIT]
	git show [COMMIT]

Branching and Tagging
---------------------

Git marks checkpoints in history by applying a label to a commit. You can create a branch with the following commands:

	git branch [NEW] [OLD]
	git checkout [NEW]

The first command creates a branch, the second command switches your tree to the new branch. You can pass an extra argument to ``git branch`` to base your new branch on a different revision than the latest one.

Running ``git branch`` without arguments lists your branches. The * in the output marks the current branch::

	git branch

To move your tree to some older revision, use::

	git checkout [COMMIT]

Git tags are fairly similar to Git branches, but with some extra tricks. Git tags can have a date, committer, and message that act just like the equivalents for Git commits. They can also be signed with a PGP key if you really want to stamp them with your seal of approval. This is great if you want to release a public version of your work, because you can have one place to store your release announcement and your guarantee that the code hasn't been tampered with. So, let's do it::

	git tag -a [NAME]

To list tags and to show a tag message::

	git tag -l
	git show [NAME]

Merging
-------

Let's suppose you are on branch "release", and you want to bring the changes you've made on "development" branch, then you'll have to do::

	git merge development

If changes were made on only one of the branches since the last merge, they are simply replayed on your other branch (a so-called fast-forward merge). If changes were made on both branches, they are merged intelligently (a so-called three-way merge). If the three-way merge doesn't have any merge conflicts, it makes a commit with a convenient log message (the ``--no-commit`` option disables this). If there are merge conflicts (when one ore more lines of a file being merged have different values in the previous state), ``git merge`` will report them and let you resolve them.

To resolve a conflict, you will have to look in the file being reported as conflict for the following pattern::

	<<<<<<< HEAD:file.txt
	Hello world
	=======
	Goodbye
	>>>>>>> 77976da35a11db4580b80ae27e8d65caf5208086:file.txt

which can be explained like this::

	<<<<<<<
	changes made on my branch
	=======
	changes made on the branch i'm merging
	>>>>>>>

You will have to erase manually which part are you going to leave. After editing all conflicts, you have to commit your changes::

	git commit -a

Aside from merging, sometimes you want to just pluck one commit out of a different branch. To apply the changes in revision rev and commit them to the current branch use::

	git cherry-pick [COMMIT]

Working with remote servers
---------------------------

If you created your repository with one of the ``clone`` commands, Git will have already set up a remote repository for you called *origin*. If you created your repository from scratch, you will have to set it up.

To see which remote servers you have configured, you can run the ``git remote`` command. It lists the shortnames of each remote handle you've specified. If you've cloned your repository, you should at least see *origin* — that is the default name Git gives to the server you cloned from::

	git remote -v

To add a new remote Git repository as a shortname you can reference easily, run::

	git remote add [SHORTNAME] [URL]

When you cloned your repository, Git downloaded all the branches and tags in that repository, and created your master branch based on the master branch in that repository. Even though it only used the master branch, it kept copies of all the others in case you needed them. Copies of branches from a remote repository are called remote branches, and don't behave quite like the local branches you've used before.

For starters, remote branches don't show up in a normal git branch. Instead, you list remote branches with ``git branch -r``. You can log these branches, diff them and merge them, but you can't commit to them, or they would stop being copies of the branch on the remote repository. If you want to work with a remote branch, you need to create a local branch that "tracks" it, like this::

	git checkout -t origin/branch

Now, how do you download new changes from a remote repository? You fetch them with ``git fetch``. But usually you don't just want to fetch, you also want to merge any changes into your local branch::

	git pull

A pull is technically a bit different to a rebase. As always, see the relevant manual pages for details.

Sharing your Work
-----------------

We saw in the previous section that you can pull other people's work into your repository, but how do your changes get back out? Well, your Git repository is as good as any other repository, so you could just ask people to git pull from you the same way you git pulled from them.

This is fine as far as Git's concerned, but what if you have a slow Internet connection, or you are behind a firewall, or you like to amend your commits before letting people see them? Most people get around this by having two repositories: a private repository they work on, and a public repository for people to pull from.

So how do you get your work onto your public repository? Well, it's the opposite of ``git pull``, so you ``git push``!

When you have your project at a point that you want to share, you have to push it upstream. The command for this is simple::

	git push [REMOTE-NAME] [BRANCH-NAME]

If you want to push your master branch to your origin server, then you can run this to push your work back up to the server::

	git push origin master

This command works only if you cloned from a server to which you have write access and if nobody has pushed in the meantime. If you and someone else clone at the same time and they push upstream and then you push upstream, your push will rightly be rejected. You’ll have to pull down their work first and incorporate it into yours before you’ll be allowed to push.

Working with submodules
-----------------------

Git submodules allows you to attach or include an external repository inside another repository at a specific path. It basically permits to handle various "subprojects" inside one big project. For example, Aguilas has two subprojects inside: the `Google code Wiki <http://code.google.com/p/aguilas/w/list>`_ (``documentation/googlewiki``) and the `GitHub Wiki <https://github.com/HuntingBears/aguilas/wiki>`_ (``documentation/githubwiki``), which both update through the command ``make gen-wiki`` on the main project.

There are four main functions you will need to understand in order to work with Git submodules. In order, you will need to know how to add, make use of, remove, and update submodules.

Adding Submodules to a Git Repository
+++++++++++++++++++++++++++++++++++++

Adding a submodule to a git repository is actually quite simple. For example, let's suppose we want to add support for another (fictionary) wiki: the mediawiki format wiki, on the ``documentation/mediawiki`` folder. You can do so with the following command::

	git submodule add git@github.com:mediawiki/wiki.git documentation/mediawiki

There are three main parts to this command:

	+ **git submodule add**:  This simply tells Git that we are adding a submodule. This syntax will always remain the same.
	+ **git@github.com:mediawiki/wiki.git**:  This is the external repository that is to be added as a submodule. The exact syntax will vary depending on the setup of the Git repository you are connecting to. You need to ensure that you have the ability to clone the given repository.
	+ **documentation/mediawiki**:  This is the path where the submodule repository will be added to the main repository.

If you make ``git status``, you will notice how the supplied path was created and added to the changes to be committed. In addition, a new file called ``.gitmodules`` was created. This new file contains the details we supplied about the new submodule. Out of curiosity, if you check out the contents of that new file::

	cat .gitmodules

::

	[submodule "documentation/mediawiki"]
	path = documentation/mediawiki
	url = git@github.com:mediawiki/wiki.git

Being able to modify this file later will come in handy later.

All that is left to do now is to commit the changes and then push the commit to a remote system if necessary.

Using Submodules
++++++++++++++++

Having submodules in a repository is great and all, but if you look inside, all you will have is an empty folder rather than the actual contents of the submodule's repository. In order to fill in the submodule's path with the files from the external repository, you must first initialize the submodules and then update them.

First, you need to initialize the submodule(s). You can do that with the following command on the root folder of the main project::

	git submodule init

Then you need to run the update in order to pull down the files:

	git submodule update

Looking in the ``documentation/mediawiki`` directory now shows a nice listing of the needed files.

Removing Submodules
+++++++++++++++++++

What happens if we need to remove a submodule? Maybe I made a mistake. It could also be that the design of the project has changed, and the submodules need to change with it. Unfortunately, Git does not have a built in way to remove submodules. we have to do it manually.

Sticking with the example, we'll remove the ``documentation/mediawiki`` module from Aguilas. All the instructions will be run from the working directory of the Aguilas repository. In order, we need to do the following:

+ **Remove the submodule's entry in the .gitmodules file**: Open it up in vim, or your favorite text editor, and remove the three lines relevant to the submodule being removed. In this case, these lines will be removed::

	[submodule "documentation/mediawiki"]
	path = documentation/mediawiki
	url = git@github.com:mediawiki/wiki.git

+ **Remove the submodule's entry in the .git/config file**: Open it up in vim, or your favorite text editor, and remove the two lines relevant to the submodule being removed. In this case, these lines will be removed::

	[submodule "documentation/mediawiki"]
	url = git@github.com:mediawiki/wiki.git

+ **Remove the path created for the submodule**: Run the following command to finish removing the submodule::

	git rm --cached documentation/mediawiki

Updating Submodules
+++++++++++++++++++

Unfortunately, like removing submodules, Git does not make it clear how to update a submodule to a later commit. Fortunately though, it's not that tough.

Initialize the repository's submodules by running ``git submodule init`` followed by ``git submodule update``::

	git submodule init
	git submodule update

Change into the submodule's directory. In this example, ``documentation/mediawiki``::

	cd documentation/mediawiki

The submodule repositories added by ``git submodule update`` are "headless". This means that they aren't on a current branch.To fix this, we simply need to switch to a branch. In this example, that would be the development branch::

	git checkout development

Next, we simply need to update the repository to ensure that we have the latest updates::

	git pull

Now switch back to the root working directory of the repository::

	cd ../..

Everything is now ready to be committed and pushed back in. If you run ``git status``, you'll notice that the path to the submodule is listed as modified. This is what you should expect to see. Simply add the path to be committed and do a commit. When you do the commit, the index will update the commit string for the submodule.

	git add .
	git commit -a

